name: Sync Upstream

on:
  schedule:
    # Run daily at 6:00 AM UTC
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      sync_releases:
        description: 'Also sync release artifacts (requires UPSTREAM_SYNC_TOKEN with repo scope)'
        default: 'false'
        required: false
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  contents: write
  pull-requests: write

env:
  UPSTREAM_REPO: billchurch/webssh2
  UPSTREAM_URL: https://github.com/billchurch/webssh2.git

jobs:
  sync-tags:
    name: Sync Tags from Upstream
    runs-on: ubuntu-latest
    outputs:
      new_tags: ${{ steps.sync.outputs.new_tags }}
      new_tag_count: ${{ steps.sync.outputs.new_tag_count }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0
          fetch-tags: true
          # Use PAT with workflow scope to push tags that may include workflow file changes
          token: ${{ secrets.SYNC_PAT || secrets.GITHUB_TOKEN }}

      - name: Sync tags from upstream
        id: sync
        run: |
          set -euo pipefail

          # Add upstream remote
          git remote add upstream "$UPSTREAM_URL" || git remote set-url upstream "$UPSTREAM_URL"

          # Fetch all tags from upstream
          echo "Fetching tags from upstream..."
          git fetch upstream --tags --force

          # Get list of upstream tags
          upstream_tags=$(git tag -l --sort=-v:refname)

          # Push all tags to origin (will skip existing ones)
          new_tags=""
          new_count=0

          for tag in $upstream_tags; do
            # Check if tag exists on origin
            if ! git ls-remote --tags origin "refs/tags/$tag" | grep -q "$tag"; then
              echo "New tag found: $tag"
              new_tags="${new_tags}${tag}\n"
              new_count=$((new_count + 1))
            fi
          done

          if [ "$new_count" -gt 0 ]; then
            echo "Pushing $new_count new tags to origin..."
            git push origin --tags
            echo "new_tags<<EOF" >> "$GITHUB_OUTPUT"
            echo -e "$new_tags" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
          else
            echo "All tags are already synced"
            echo "new_tags=" >> "$GITHUB_OUTPUT"
          fi

          echo "new_tag_count=$new_count" >> "$GITHUB_OUTPUT"

  sync-main:
    name: Sync Main Branch
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check.outputs.has_changes }}
      pr_url: ${{ steps.create-pr.outputs.pr_url }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0
          ref: main

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for upstream changes
        id: check
        run: |
          set -euo pipefail

          # Add upstream remote
          git remote add upstream "$UPSTREAM_URL" || git remote set-url upstream "$UPSTREAM_URL"

          # Fetch upstream main
          git fetch upstream main

          # Check if there are new commits from upstream
          if [ -z "$(git rev-list main..upstream/main)" ]; then
            echo "No new commits from upstream"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "New commits detected from upstream"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"

            # Show what changed
            echo "## New commits from upstream:" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            git log main..upstream/main --oneline | head -20 >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Create sync branch and PR
        id: create-pr
        if: steps.check.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.SYNC_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Create branch name with date
          branch_name="sync-upstream-$(date +%Y%m%d)"

          # Start from main and merge upstream (preserves local changes)
          git checkout -B "$branch_name" main

          # Merge upstream - this preserves our local customizations
          # Use -X theirs for conflicts in non-critical files, but this should rarely happen
          if ! git merge upstream/main --no-edit -m "Merge upstream billchurch/webssh2 into main"; then
            echo "::warning::Merge conflicts detected - manual resolution may be needed"
            # Show conflicts in summary
            echo "## Merge Conflicts" >> "$GITHUB_STEP_SUMMARY"
            echo "The following files have conflicts that need manual resolution:" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            git diff --name-only --diff-filter=U >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            # Abort and exit - manual intervention needed
            git merge --abort
            echo "has_conflicts=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git push origin "$branch_name" --force

          # Check if PR already exists for this branch
          existing_pr=$(gh pr list --head "$branch_name" --json number --jq '.[0].number // empty')

          if [ -n "$existing_pr" ]; then
            echo "PR #$existing_pr already exists for branch $branch_name"
            pr_url=$(gh pr view "$existing_pr" --json url --jq '.url')
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
          else
            # Get commit summary for PR body
            commit_count=$(git rev-list main..upstream/main --count)
            commit_log=$(git log main..upstream/main --oneline --no-decorate | head -20)

            if [ "$commit_count" -gt 20 ]; then
              commit_log="${commit_log}\n... and $((commit_count - 20)) more commits"
            fi

            # Create PR
            pr_url=$(gh pr create \
              --title "Sync with upstream billchurch/webssh2" \
              --body "$(cat <<EOF
          ## Upstream Sync

          This PR syncs changes from upstream [billchurch/webssh2](https://github.com/billchurch/webssh2).

          ### Commits from upstream ($commit_count total):

          \`\`\`
          $commit_log
          \`\`\`

          ### Review Checklist

          - [ ] Review changes for any security concerns
          - [ ] Verify CI passes
          - [ ] Check for breaking changes that might affect downstream consumers

          ---
          *This PR was automatically created by the [sync-upstream workflow](.github/workflows/sync-upstream.yml).*
          EOF
          )" \
              --base main \
              --head "$branch_name")

            echo "Created PR: $pr_url"
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
          fi

  sync-releases:
    name: Sync Release Artifacts
    runs-on: ubuntu-latest
    needs: sync-tags
    if: github.event.inputs.sync_releases == 'true' && needs.sync-tags.outputs.new_tag_count != '0'
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Sync release artifacts
        env:
          GH_TOKEN: ${{ secrets.UPSTREAM_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
          NEW_TAGS: ${{ needs.sync-tags.outputs.new_tags }}
        run: |
          set -euo pipefail

          echo "Syncing release artifacts for new tags..."

          # Process each new tag
          echo -e "$NEW_TAGS" | while read -r tag; do
            [ -z "$tag" ] && continue

            echo "Processing tag: $tag"

            # Check if this tag has a release on upstream
            upstream_release=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$UPSTREAM_REPO/releases/tags/$tag" || echo "{}")

            if echo "$upstream_release" | jq -e '.id' > /dev/null 2>&1; then
              release_name=$(echo "$upstream_release" | jq -r '.name // .tag_name')
              release_body=$(echo "$upstream_release" | jq -r '.body // ""')
              is_prerelease=$(echo "$upstream_release" | jq -r '.prerelease')

              echo "Found upstream release: $release_name"

              # Check if release already exists in fork
              if gh release view "$tag" > /dev/null 2>&1; then
                echo "Release $tag already exists in fork, skipping..."
                continue
              fi

              # Create release in fork
              prerelease_flag=""
              if [ "$is_prerelease" = "true" ]; then
                prerelease_flag="--prerelease"
              fi

              gh release create "$tag" \
                --title "$release_name" \
                --notes "$release_body

          ---
          *Mirrored from [upstream release](https://github.com/$UPSTREAM_REPO/releases/tag/$tag)*" \
                $prerelease_flag || echo "Failed to create release for $tag"

              # Download and upload assets
              assets=$(echo "$upstream_release" | jq -r '.assets[].browser_download_url')
              if [ -n "$assets" ]; then
                mkdir -p /tmp/release-assets
                cd /tmp/release-assets

                echo "$assets" | while read -r asset_url; do
                  [ -z "$asset_url" ] && continue
                  asset_name=$(basename "$asset_url")
                  echo "Downloading: $asset_name"
                  curl -sL -o "$asset_name" "$asset_url"
                  gh release upload "$tag" "$asset_name" --clobber || echo "Failed to upload $asset_name"
                done

                cd -
                rm -rf /tmp/release-assets
              fi

              echo "Synced release: $tag"
            else
              echo "No release found for tag $tag on upstream"
            fi
          done

  summary:
    name: Sync Summary
    runs-on: ubuntu-latest
    needs: [sync-tags, sync-main]
    if: always()
    steps:
      - name: Generate summary
        env:
          NEW_TAG_COUNT: ${{ needs.sync-tags.outputs.new_tag_count }}
          NEW_TAGS: ${{ needs.sync-tags.outputs.new_tags }}
          HAS_CHANGES: ${{ needs.sync-main.outputs.has_changes }}
          PR_URL: ${{ needs.sync-main.outputs.pr_url }}
        run: |
          echo "## Upstream Sync Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "### Tags" >> "$GITHUB_STEP_SUMMARY"
          if [ "${NEW_TAG_COUNT:-0}" -gt 0 ]; then
            echo "âœ… Synced **$NEW_TAG_COUNT** new tag(s) from upstream" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            echo -e "$NEW_TAGS" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âœ… All tags are already in sync" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "### Main Branch" >> "$GITHUB_STEP_SUMMARY"
          if [ "${HAS_CHANGES:-false}" = "true" ]; then
            echo "ðŸ”„ Changes detected from upstream" >> "$GITHUB_STEP_SUMMARY"
            if [ -n "${PR_URL:-}" ]; then
              echo "ðŸ“ Pull Request: $PR_URL" >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "âœ… Main branch is already in sync" >> "$GITHUB_STEP_SUMMARY"
          fi
